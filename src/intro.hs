{-------------------------------------------------------------------------------
-- {BEGIN: intro}

                     _   _           _        _ _
                    | | | | __ _ ___| | _____| | |
                    | |_| |/ _` / __| |/ / _ \ | |
                    |  _  | (_| \__ \   <  __/ | |
                    |_| |_|\__,_|___/_|\_\___|_|_|

                            The Easy Stuff

                   Peter Jones <pjones@devalot.com>

-- {END}
-------------------------------------------------------------------------------}

{-------------------------------------------------------------------------------
-- {BEGIN: functions}

             _____                 _   _
            |  ___|   _ _ __   ___| |_(_) ___  _ __  ___
            | |_ | | | | '_ \ / __| __| |/ _ \| '_ \/ __|
            |  _|| |_| | | | | (__| |_| | (_) | | | \__ \
            |_|   \__,_|_| |_|\___|\__|_|\___/|_| |_|___/


-- {END}
-------------------------------------------------------------------------------}

--------------------------------------------------------------------------------
-- Let the compiler figure out the types.
-- {BEGIN: square}

mySquare x = x * x

-- {END}

--------------------------------------------------------------------------------
-- Only work with integers.
-- {BEGIN: square'}

mySquare' :: Int -> Int
mySquare' x = x * x

-- {END}

--------------------------------------------------------------------------------
-- Work with any numeric type.
-- {BEGIN: square''}

mySquare'' :: Num a => a -> a
mySquare'' x = x * x

-- {END}

--------------------------------------------------------------------------------
-- Using functions as operators and partial application.
-- {BEGIN: add}

myAdd :: Num a => a -> a -> a
myAdd x y = x + y

-- {END}

--------------------------------------------------------------------------------
-- Currying.
-- {BEGIN: add'}

myAdd' :: Num a => a -> a -> a
myAdd' x = \y -> x + y

-- {END}

--------------------------------------------------------------------------------
-- Pattern matching and recursion.
-- {BEGIN: sum}

mySum :: Num a => [a] -> a
mySum []     = 0
mySum (x:xs) = x + mySum xs

-- {END}
